import { ErrorCode, RecordType } from "./constants.js";
export declare type DNSRecord = {};
export interface AnyDNSRecord {
    type: string;
}
export interface ARecord extends DNSRecord {
    address: string;
    ttl: number;
}
export interface AnyARecord extends ARecord {
    type: 'A';
}
export interface AAAARecord extends DNSRecord {
    address: string;
    ttl: number;
}
export interface AnyAAAARecord extends AAAARecord {
    type: 'AAAA';
}
export interface CNAMERecord extends DNSRecord {
    value: string;
}
export interface AnyCNAMERecord extends CNAMERecord {
    type: 'CNAME';
}
export interface CAARecord extends DNSRecord {
    critical: number;
    iodef?: string;
    issue?: string;
}
export interface AnyCAARecord extends CAARecord {
    type: 'CAA';
}
export interface NSRecord extends DNSRecord {
    value: string;
}
export interface AnyNSRecord extends NSRecord {
    type: 'NS';
}
export interface PTRRecord extends DNSRecord {
    value: string;
}
export interface AnyPTRRecord extends PTRRecord {
    type: 'PTR';
}
export interface TXTRecord extends DNSRecord {
    entries: string[];
}
export interface AnyTXTRecord extends TXTRecord {
    type: 'TXT';
}
export interface MXRecord extends DNSRecord {
    priority: number;
    exchange: string;
}
export interface AnyMXRecord extends MXRecord {
    type: 'MX';
}
export interface NAPTRRecord extends DNSRecord {
    order: number;
    preference: number;
    flags: string;
    service: string;
    regexp: string;
    replacement: string;
}
export interface AnyNAPTRRecord extends NAPTRRecord {
    type: 'NAPTR';
}
export interface SOARecord extends DNSRecord {
    nsname: string;
    hostmaster: string;
    serial: number;
    refresh: number;
    retry: number;
    expire: number;
    minttl: number;
}
export interface AnySOARecord extends SOARecord {
    type: 'SOA';
}
export interface SRVRecord extends DNSRecord {
    priority: number;
    weight: number;
    port: number;
    name: string;
}
export interface AnySRVRecord extends SRVRecord {
    type: 'SRV';
}
export declare class DNSError extends Error {
    code: ErrorCode;
    constructor(message: string, code: ErrorCode);
    static readonly NODATA: DNSError;
    static readonly FORMERR: DNSError;
    static readonly SERVFAIL: DNSError;
    static readonly NOTFOUND: DNSError;
    static readonly NOTIMP: DNSError;
    static readonly REFUSED: DNSError;
    static readonly BADQUERY: DNSError;
    static readonly BADNAME: DNSError;
    static readonly BADFAMILY: DNSError;
    static readonly BADRESP: DNSError;
    static readonly CONNREFUSED: DNSError;
    static readonly TIMEOUT: DNSError;
    static readonly EOF: DNSError;
    static readonly FILE: DNSError;
    static readonly NOMEM: DNSError;
    static readonly DESTRUCTION: DNSError;
    static readonly BADSTR: DNSError;
    static readonly BADFLAGS: DNSError;
    static readonly NONAME: DNSError;
    static readonly BADHINTS: DNSError;
    static readonly NOTINITIALIZED: DNSError;
    static readonly LOADIPHLPAPI: DNSError;
    static readonly ADDRGETNETWORKPARAMS: DNSError;
    static readonly CANCELLED: DNSError;
}
export declare type LookupCallback = (err?: DNSError, address?: string, family?: number) => void;
export declare type LookupCallbackAll = (err?: DNSError, addresses?: {
    address: string;
    family: number;
}[]) => void;
export interface Resolver {
    cancel(): void;
    setLocalAddress(ipv4: string, ipv6: string): void;
    getServers(): string[];
    setServers(servers: string[]): void;
    resolve(hostname: string, callback: (err?: DNSError, records?: string[]) => void): void;
    resolve(hostname: string, rrtype: "A" | "AAAA" | "CNAME" | "NS" | "PTR", callback: (err?: DNSError, records?: string[]) => void): void;
    resolve(hostname: string, rrtype: 'ANY', callback: (err?: DNSError, records?: AnyDNSRecord[]) => void): void;
    resolve(hostname: string, rrtype: 'CAA', callback: (err?: DNSError, records?: CAARecord[]) => void): void;
    resolve(hostname: string, rrtype: 'MX', callback: (err?: DNSError, records?: MXRecord[]) => void): void;
    resolve(hostname: string, rrtype: 'NAPTR', callback: (err?: DNSError, records?: NAPTRRecord[]) => void): void;
    resolve(hostname: string, rrtype: 'SOA', callback: (err?: DNSError, records?: SOARecord) => void): void;
    resolve(hostname: string, rrtype: 'SRV', callback: (err?: DNSError, records?: SRVRecord[]) => void): void;
    resolve(hostname: string, rrtype: 'TXT', callback: (err?: DNSError, records?: string[][]) => void): void;
    resolve4(hostname: string, callback: (err?: DNSError, address?: string[]) => void): void;
    resolve4(hostname: string, options: {
        ttl: true;
    }, callback: (err?: DNSError, address?: ARecord[]) => void): void;
    resolve4(hostname: string, options: {
        ttl: false;
    }, callback: (err?: DNSError, address?: string[]) => void): void;
    resolve6(hostname: string, callback: (err?: DNSError, address?: string[]) => void): void;
    resolve6(hostname: string, options: {
        ttl: true;
    }, callback: (err?: DNSError, address?: AAAARecord[]) => void): void;
    resolve6(hostname: string, options: {
        ttl: false;
    }, callback: (err?: DNSError, address?: string[]) => void): void;
    resolveAny(hostname: string, callback: (err?: DNSError, ret?: AnyDNSRecord[]) => void): void;
    resolveCaa(hostname: string, callback: (err?: DNSError, records?: {
        critical: number;
        iodef?: string;
        issue?: string;
    }[]) => void): void;
    resolveCname(hostname: string, callback: (err?: DNSError, addresses?: string[]) => void): void;
    resolveMx(hostname: string, callback: (err?: DNSError, addresses?: {
        priority: number;
        exchange: string;
    }[]) => void): void;
    resolveNaptr(hostname: string, callback: (err?: DNSError, addresses?: NAPTRRecord[]) => void): void;
    resolveNs(hostname: string, callback: (err?: DNSError, addresses?: string[]) => void): void;
    resolvePtr(hostname: string, callback: (err?: DNSError, addresses?: string[]) => void): void;
    resolveSoa(hostname: string, callback: (err?: DNSError, address?: SOARecord) => void): void;
    resolveSrv(hostname: string, callback: (err?: DNSError, addresses?: SRVRecord[]) => void): void;
    resolveTxt(hostname: string, callback: (err?: DNSError, records?: string[][]) => void): void;
    reverse(hostname: string, callback: (err?: DNSError, hostnames?: string[]) => void): void;
}
export declare type ResolveOptions = {
    ttl?: boolean;
    raw?: boolean;
};
export interface PromiseResolver {
    cancel(): void;
    setLocalAddress(ipv4: string, ipv6: string): void;
    getServers(): string[];
    setServers(servers: string[]): void;
    resolve(hostname: string, rrtype: "ANY", options?: {
        raw: false;
    }): Promise<AnyDNSRecord[]>;
    resolve(hostname: string, rrtype: "CAA", options?: {
        raw: false;
    }): Promise<CAARecord[]>;
    resolve(hostname: string, rrtype: "MX", options?: {
        raw: false;
    }): Promise<MXRecord[]>;
    resolve(hostname: string, rrtype: "NAPTR", options?: {
        raw: false;
    }): Promise<NAPTRRecord[]>;
    resolve(hostname: string, rrtype: "SOA", options?: {
        raw: false;
    }): Promise<SOARecord>;
    resolve(hostname: string, rrtype: "SRV", options?: {
        raw: false;
    }): Promise<SRVRecord[]>;
    resolve(hostname: string, rrtype: "TXT", options?: {
        raw: false;
    }): Promise<string[][]>;
    resolve(hostname: string, rrtype?: "A" | "AAAA" | "CNAME" | "NS" | "PTR", options?: {
        raw: false;
    }): Promise<string[]>;
    resolve(hostname: string, rrtype: keyof typeof RecordType, options: {
        raw: true;
    }): Promise<any>;
    resolve(hostname: string, rrtype: "A", options: {
        ttl: true;
        raw: false;
    }): Promise<ARecord[]>;
    resolve(hostname: string, rrtype: "AAAA", options: {
        ttl: true;
        raw: false;
    }): Promise<AAAARecord[]>;
    resolve4(hostname: string, options: {
        ttl: true;
    }): Promise<ARecord[]>;
    resolve4(hostname: string, options?: {
        ttl: false;
    }): Promise<string[]>;
    resolve6(hostname: string, options: {
        ttl: true;
    }): Promise<AAAARecord[]>;
    resolve6(hostname: string, options?: {
        ttl: false;
    }): Promise<string[]>;
    resolveAny(hostname: string): Promise<AnyDNSRecord[]>;
    resolveCaa(hostname: string): Promise<{
        critical: number;
        iodef?: string;
        issue?: string;
    }[]>;
    resolveCname(hostname: string): Promise<string[]>;
    resolveMx(hostname: string): Promise<{
        priority: number;
        exchange: string;
    }[]>;
    resolveNaptr(hostname: string): Promise<NAPTRRecord[]>;
    resolveNs(hostname: string): Promise<string[]>;
    resolvePtr(hostname: string): Promise<string[]>;
    resolveSoa(hostname: string): Promise<SOARecord>;
    resolveSrv(hostname: string): Promise<SRVRecord[]>;
    resolveTxt(hostname: string): Promise<string[][]>;
    reverse(hostname: string): Promise<string[]>;
    lookup(hostname: string): Promise<{
        address: string;
        family: number;
    }>;
    lookup(hostname: string, options: 4 | 6 | {
        family: 4 | 6 | 0;
        hints?: number;
        all?: boolean;
        verbatim?: boolean;
    }): Promise<{
        address: string;
        family: number;
    } | {
        address: string;
        family: number;
    }[]>;
    lookupService(address: string, port: number): Promise<{
        hostname: string;
        service: string;
    }>;
}
