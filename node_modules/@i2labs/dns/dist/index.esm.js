var RecordType;
(function (RecordType) {
    RecordType[RecordType["A"] = 1] = "A";
    RecordType[RecordType["NS"] = 2] = "NS";
    RecordType[RecordType["MD"] = 3] = "MD";
    RecordType[RecordType["MF"] = 4] = "MF";
    RecordType[RecordType["CNAME"] = 5] = "CNAME";
    RecordType[RecordType["SOA"] = 6] = "SOA";
    RecordType[RecordType["MB"] = 7] = "MB";
    RecordType[RecordType["MG"] = 8] = "MG";
    RecordType[RecordType["MR"] = 9] = "MR";
    RecordType[RecordType["NULL"] = 10] = "NULL";
    RecordType[RecordType["WKS"] = 11] = "WKS";
    RecordType[RecordType["PTR"] = 12] = "PTR";
    RecordType[RecordType["HINFO"] = 13] = "HINFO";
    RecordType[RecordType["MINFO"] = 14] = "MINFO";
    RecordType[RecordType["MX"] = 15] = "MX";
    RecordType[RecordType["TXT"] = 16] = "TXT";
    RecordType[RecordType["RP"] = 17] = "RP";
    RecordType[RecordType["AFSDB"] = 18] = "AFSDB";
    RecordType[RecordType["X25"] = 19] = "X25";
    RecordType[RecordType["ISDN"] = 20] = "ISDN";
    RecordType[RecordType["RT"] = 21] = "RT";
    RecordType[RecordType["NSAP"] = 22] = "NSAP";
    RecordType[RecordType["NSAP-PTR"] = 23] = "NSAP-PTR";
    RecordType[RecordType["SIG"] = 24] = "SIG";
    RecordType[RecordType["KEY"] = 25] = "KEY";
    RecordType[RecordType["PX"] = 26] = "PX";
    RecordType[RecordType["GPOS"] = 27] = "GPOS";
    RecordType[RecordType["AAAA"] = 28] = "AAAA";
    RecordType[RecordType["LOC"] = 29] = "LOC";
    RecordType[RecordType["NXT"] = 30] = "NXT";
    RecordType[RecordType["EID"] = 31] = "EID";
    RecordType[RecordType["NIMLOC"] = 32] = "NIMLOC";
    RecordType[RecordType["SRV"] = 33] = "SRV";
    RecordType[RecordType["ATMA"] = 34] = "ATMA";
    RecordType[RecordType["NAPTR"] = 35] = "NAPTR";
    RecordType[RecordType["KX"] = 36] = "KX";
    RecordType[RecordType["CERT"] = 37] = "CERT";
    RecordType[RecordType["A6"] = 38] = "A6";
    RecordType[RecordType["DNAME"] = 39] = "DNAME";
    RecordType[RecordType["SINK"] = 40] = "SINK";
    RecordType[RecordType["OPT"] = 41] = "OPT";
    RecordType[RecordType["APL"] = 42] = "APL";
    RecordType[RecordType["DS"] = 43] = "DS";
    RecordType[RecordType["SSHFP"] = 44] = "SSHFP";
    RecordType[RecordType["IPSECKEY"] = 45] = "IPSECKEY";
    RecordType[RecordType["RRSIG"] = 46] = "RRSIG";
    RecordType[RecordType["NSEC"] = 47] = "NSEC";
    RecordType[RecordType["DNSKEY"] = 48] = "DNSKEY";
    RecordType[RecordType["DHCID"] = 49] = "DHCID";
    RecordType[RecordType["NSEC3"] = 50] = "NSEC3";
    RecordType[RecordType["NSEC3PARAM"] = 51] = "NSEC3PARAM";
    RecordType[RecordType["TLSA"] = 52] = "TLSA";
    RecordType[RecordType["SMIMEA"] = 53] = "SMIMEA";
    // 'Unassigned1' = 54,
    RecordType[RecordType["HIP"] = 55] = "HIP";
    RecordType[RecordType["NINFO"] = 56] = "NINFO";
    RecordType[RecordType["RKEY"] = 57] = "RKEY";
    RecordType[RecordType["TALINK"] = 58] = "TALINK";
    RecordType[RecordType["CDS"] = 59] = "CDS";
    RecordType[RecordType["CDNSKEY"] = 60] = "CDNSKEY";
    RecordType[RecordType["OPENPGPKEY"] = 61] = "OPENPGPKEY";
    RecordType[RecordType["CSYNC"] = 62] = "CSYNC";
    RecordType[RecordType["ZONEMD"] = 63] = "ZONEMD";
    RecordType[RecordType["SVCB"] = 64] = "SVCB";
    RecordType[RecordType["HTTPSSVC"] = 65] = "HTTPSSVC";
    // 'Unassigned2' = 64-98,
    RecordType[RecordType["SPF"] = 99] = "SPF";
    RecordType[RecordType["UINFO"] = 100] = "UINFO";
    RecordType[RecordType["UID"] = 101] = "UID";
    RecordType[RecordType["GID"] = 102] = "GID";
    RecordType[RecordType["UNSPEC"] = 103] = "UNSPEC";
    RecordType[RecordType["NID"] = 104] = "NID";
    RecordType[RecordType["L32"] = 105] = "L32";
    RecordType[RecordType["L64"] = 106] = "L64";
    RecordType[RecordType["LP"] = 107] = "LP";
    RecordType[RecordType["EUI48"] = 108] = "EUI48";
    RecordType[RecordType["EUI64"] = 109] = "EUI64";
    // 'Unassigned3' = 110-248,    // TKEY     249     Transaction Key     [RFC2930]
    RecordType[RecordType["TSIG"] = 250] = "TSIG";
    RecordType[RecordType["IXFR"] = 251] = "IXFR";
    RecordType[RecordType["AXFR"] = 252] = "AXFR";
    RecordType[RecordType["MAILB"] = 253] = "MAILB";
    RecordType[RecordType["MAILA"] = 254] = "MAILA";
    RecordType[RecordType["*"] = 255] = "*";
    RecordType[RecordType["URI"] = 256] = "URI";
    RecordType[RecordType["CAA"] = 257] = "CAA";
    RecordType[RecordType["AVC"] = 258] = "AVC";
    RecordType[RecordType["DOA"] = 259] = "DOA";
    RecordType[RecordType["AMTRELAY"] = 260] = "AMTRELAY";
    // 'Unassigned4' = 261-32767,
    RecordType[RecordType["TA"] = 32768] = "TA";
    RecordType[RecordType["DLV"] = 32769] = "DLV";
    // 'Unassigned5' = 32770-65279,    // Private use     65280-65534
    // 'Reserved' = 65535,
})(RecordType || (RecordType = {}));
// Each DNS query can return one of the following error codes:
const NODATA = 'NODATA'; // DNS server returned answer with no data.
const FORMERR = 'FORMERR'; // DNS server claims query was misformatted.
const SERVFAIL = 'SERVFAIL'; // DNS server returned general failure.
const NOTFOUND = 'NOTFOUND'; // Domain name not found.
const NOTIMP = 'NOTIMP'; // DNS server does not implement requested operation.
const REFUSED = 'REFUSED'; // DNS server refused query.
const BADQUERY = 'BADQUERY'; // Misformatted DNS query.
const BADNAME = 'BADNAME'; // Misformatted host name.
const BADFAMILY = 'BADFAMILY'; // Unsupported address family.
const BADRESP = 'BADRESP'; // Misformatted DNS reply.
const CONNREFUSED = 'CONNREFUSED'; // Could not contact DNS servers.
const TIMEOUT = 'TIMEOUT'; // Timeout while contacting DNS servers.
const EOF = 'EOF'; // End of file.
const FILE = 'FILE'; // Error reading file.
const NOMEM = 'NOMEM'; // Out of memory.
const DESTRUCTION = 'DESTRUCTION'; // Channel is being destroyed.
const BADSTR = 'BADSTR'; // Misformatted string.
const BADFLAGS = 'BADFLAGS'; // Illegal flags specified.
const NONAME = 'NONAME'; // Given host name is not numeric.
const BADHINTS = 'BADHINTS'; // Illegal hints flags specified.
const NOTINITIALIZED = 'NOTINITIALIZED'; // c-ares library initialization not yet performed.
const LOADIPHLPAPI = 'LOADIPHLPAPI'; // Error loading iphlpapi.dll.
const ADDRGETNETWORKPARAMS = 'ADDRGETNETWORKPARAMS'; // Could not find GetNetworkParams function.
const CANCELLED = 'CANCELLED'; // DNS query cancelled.

var constants = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get RecordType () { return RecordType; },
    NODATA: NODATA,
    FORMERR: FORMERR,
    SERVFAIL: SERVFAIL,
    NOTFOUND: NOTFOUND,
    NOTIMP: NOTIMP,
    REFUSED: REFUSED,
    BADQUERY: BADQUERY,
    BADNAME: BADNAME,
    BADFAMILY: BADFAMILY,
    BADRESP: BADRESP,
    CONNREFUSED: CONNREFUSED,
    TIMEOUT: TIMEOUT,
    EOF: EOF,
    FILE: FILE,
    NOMEM: NOMEM,
    DESTRUCTION: DESTRUCTION,
    BADSTR: BADSTR,
    BADFLAGS: BADFLAGS,
    NONAME: NONAME,
    BADHINTS: BADHINTS,
    NOTINITIALIZED: NOTINITIALIZED,
    LOADIPHLPAPI: LOADIPHLPAPI,
    ADDRGETNETWORKPARAMS: ADDRGETNETWORKPARAMS,
    CANCELLED: CANCELLED
});

class DNSError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
DNSError.NODATA = new DNSError('DNS server returned answer with no data', NODATA);
DNSError.FORMERR = new DNSError('DNS server claims query was misformatted', FORMERR);
DNSError.SERVFAIL = new DNSError('DNS server returned general failure', SERVFAIL);
DNSError.NOTFOUND = new DNSError('Domain name not found', NOTFOUND);
DNSError.NOTIMP = new DNSError('DNS server does not implement requested operation', NOTIMP);
DNSError.REFUSED = new DNSError('DNS server refused query', REFUSED);
DNSError.BADQUERY = new DNSError('Misformatted DNS query', BADQUERY);
DNSError.BADNAME = new DNSError('Misformatted host name', BADNAME);
DNSError.BADFAMILY = new DNSError('Unsupported address family', BADFAMILY);
DNSError.BADRESP = new DNSError('Misformatted DNS reply', BADRESP);
DNSError.CONNREFUSED = new DNSError('Could not contact DNS servers', CONNREFUSED);
DNSError.TIMEOUT = new DNSError('Timeout while contacting DNS servers', TIMEOUT);
DNSError.EOF = new DNSError('End of file', EOF);
DNSError.FILE = new DNSError('Error reading file', FILE);
DNSError.NOMEM = new DNSError('Out of memory', NOMEM);
DNSError.DESTRUCTION = new DNSError('Channel is being destroyed', DESTRUCTION);
DNSError.BADSTR = new DNSError('Misformatted string', BADSTR);
DNSError.BADFLAGS = new DNSError('Illegal flags specified', BADFLAGS);
DNSError.NONAME = new DNSError('Given host name is not numeric', NONAME);
DNSError.BADHINTS = new DNSError('Illegal hints flags specified', BADHINTS);
DNSError.NOTINITIALIZED = new DNSError('c-ares library initialization not yet performed', NOTINITIALIZED);
DNSError.LOADIPHLPAPI = new DNSError('Error loading iphlpapi.dll', LOADIPHLPAPI);
DNSError.ADDRGETNETWORKPARAMS = new DNSError('Could not find GetNetworkParams function', ADDRGETNETWORKPARAMS);
DNSError.CANCELLED = new DNSError('DNS query cancelled', CANCELLED);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class BaseResolver {
    constructor(options) {
        this._timeout = -1;
        this._pending = new Set();
        if (options)
            this._timeout = options.timeout;
    }
    cancel() {
        for (const controller of this._pending)
            controller.abort();
        this._pending.clear();
    }
    _fetch(resource, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const controller = new AbortController();
            let id;
            this._pending.add(controller);
            if (this._timeout !== -1)
                id = setTimeout(() => controller.abort(), this._timeout);
            try {
                return yield fetch(resource, Object.assign(Object.assign({}, options), { signal: controller.signal }));
            }
            catch (e) {
                if (e.name === 'AbortError')
                    throw new DNSError('request was cancelled', CANCELLED);
                throw (e);
            }
            finally {
                this._pending.delete(controller);
                if (id)
                    clearTimeout(id);
            }
        });
    }
    setLocalAddress(ipv4, ipv6) {
        // no-op
    }
    getServers() {
        return this.servers;
    }
    setServers(servers) {
        if (servers.length === 0)
            throw new RangeError("At least one server is required");
        this.servers = servers;
    }
    resolve4(hostname, options) {
        return this.resolve(hostname, 'A', options);
    }
    resolve6(hostname, options) {
        return this.resolve(hostname, 'AAAA', options);
    }
    resolveAny(hostname) {
        return this.resolve(hostname, 'ANY');
    }
    resolveCaa(hostname) {
        return this.resolve(hostname, 'CAA');
    }
    resolveCname(hostname) {
        return this.resolve(hostname, 'CNAME');
    }
    resolveMx(hostname) {
        return this.resolve(hostname, 'MX');
    }
    resolveNaptr(hostname) {
        return this.resolve(hostname, 'NAPTR');
    }
    resolveNs(hostname) {
        return this.resolve(hostname, 'NS');
    }
    resolvePtr(hostname) {
        return this.resolve(hostname, 'PTR');
    }
    resolveSoa(hostname) {
        return this.resolve(hostname, 'SOA');
    }
    resolveSrv(hostname) {
        return this.resolve(hostname, 'SRV');
    }
    resolveTxt(hostname) {
        return this.resolve(hostname, 'TXT');
    }
    reverse(hostname) {
        throw DNSError.NOTIMP;
    }
}

function IP4ADDR(d) { return (new Array(4)).fill(undefined).map(x => Number(d.next('u8').value)); }
function IP6ADDR(d) { return (new Array(8)).fill(undefined).map(x => Number(d.next('u16').value)); }
function EXP(d) { return d.next('u4').value * Math.pow(10, d.next('u4').value); }
const DOMAINNAME = 'string[]';
const rdata = new Map();
rdata.set(RecordType.A, IP4ADDR);
rdata.set(RecordType.NS, DOMAINNAME);
rdata.set(RecordType.MD, DOMAINNAME);
rdata.set(RecordType.MF, DOMAINNAME);
rdata.set(RecordType.CNAME, DOMAINNAME);
rdata.set(RecordType.SOA, { MNAME: DOMAINNAME, RNAME: DOMAINNAME, SERIAL: 'u32', REFRESH: 'u32', RETRY: 'u32', EXPIRE: 'u32', MINIMUM: 'u32' });
rdata.set(RecordType.MB, DOMAINNAME);
rdata.set(RecordType.MG, DOMAINNAME);
rdata.set(RecordType.MR, DOMAINNAME);
rdata.set(RecordType.NULL, 'string[*]');
rdata.set(RecordType.WKS, { ADDRESS: IP4ADDR, PROTOCOL: 'u8', BITMAP: 'opaque' });
rdata.set(RecordType.PTR, DOMAINNAME);
rdata.set(RecordType.HINFO, { CPU: 'string', OS: 'string' });
rdata.set(RecordType.MINFO, { RMAILBX: DOMAINNAME, EMAILBX: DOMAINNAME });
rdata.set(RecordType.MX, { PREFERENCE: 's16', EXCHANGE: DOMAINNAME });
rdata.set(RecordType.TXT, 'string[]');
rdata.set(RecordType.RP, { mbox: DOMAINNAME, txt: DOMAINNAME });
rdata.set(RecordType.AFSDB, { subtype: 's16', hostname: DOMAINNAME });
rdata.set(RecordType.X25, 'string');
rdata.set(RecordType.ISDN, (d) => { const v = { address: d.next('string').value, sa: undefined }; const n = d.next(); v.sa = n.done ? undefined : n.value; return v; });
rdata.set(RecordType.RT, { preference: 's16', 'intermediate-host': DOMAINNAME });
rdata.set(RecordType.NSAP, 'string');
rdata.set(RecordType['NSAP-PTR'], 'string');
rdata.set(RecordType.SIG, { type_covered: 'u16', algorithm: 'u8', labels: 'u8', original_ttl: 'u32', sig_expiration: 'u32', sig_inception: 'u32', key_tag: 'u16', signer: DOMAINNAME, signature: 'opaque' });
rdata.set(RecordType.KEY, { flags: 'u16', protocol: 'u8', algorithm: 'u8', public_key: 'opaque' });
rdata.set(RecordType.PX, { PREFERENCE: 's16', MAP822: DOMAINNAME, MAPX400: DOMAINNAME });
rdata.set(RecordType.GPOS, { LONGITUDE: 'string', LATITUDE: 'string', ALTITUDE: 'string' });
rdata.set(RecordType.AAAA, IP6ADDR);
rdata.set(RecordType.LOC, (d) => {
    const val = parseToken(d, { VERSION: 'u8', SIZE: EXP, HORIZ_PRE: EXP, VERT_PRE: EXP, LATITUDE: 'u32', LONGITUDE: 'u32', ALTITUDE: 'u32' });
    const dms = (n) => ({ d: Math.abs(Math.trunc(n / 3600000)), m: Math.abs(Math.trunc((n % 3600000) / 60000)), s: Math.abs(((n % 3600000) % 60000) / 1000) });
    val.size = val.SIZE / 100;
    val.horiz_pre = val.HORIZ_PRE / 100;
    val.vert_pre = val.VERT_PRE / 100;
    val.latitude = dms(val.LATITUDE - Math.pow(2, 31));
    val.latitude.ns = val.LATITUDE <= 0 ? "N" : "S";
    val.longitude = dms(val.LONGITUDE - Math.pow(2, 31));
    val.longitude.ew = val.LONGITUDE <= 0 ? "E" : "W";
    val.altitude = val.ALTITUDE / 100 - 100000;
    return val;
});
rdata.set(RecordType.NXT, { next_domain_name: DOMAINNAME, type_bit_map: 'opaque' });
rdata.set(RecordType.EID, 'opaque');
rdata.set(RecordType.NIMLOC, 'opaque');
rdata.set(RecordType.SRV, { priority: 'u16', weight: 'u16', port: 'u16', target: DOMAINNAME });
rdata.set(RecordType.ATMA, 'opaque');
rdata.set(RecordType.NAPTR, { ORDER: 'u16', PREFERENCE: 'u16', FLAGS: 'string', SERVICES: 'string', REGEXP: 'string', REPLACEMENT: DOMAINNAME });
rdata.set(RecordType.KX, { PREFERENCE: 'u16', EXCHANGER: DOMAINNAME });
rdata.set(RecordType.CERT, { type: 'u16', key_tag: 'u16', algorithm: 'u8', certificate: 'opaque' });
rdata.set(RecordType.A6, 'opaque');
rdata.set(RecordType.DNAME, DOMAINNAME);
rdata.set(RecordType.SINK, { coding: 'u8', subcoding: 'u8', data: 'opaque' });
rdata.set(RecordType.OPT, { code: 'u16', length: 'u16', data: 'opaque' });
rdata.set(RecordType.APL, { ADDRESSFAMILY: 'u16', PREFIX: 'u8', N: 'bit', AFDLENGTH: (d) => (new Array(7)).fill(undefined).map(x => d.next('bit').value).reduce((acc, cur) => ((acc << 1) + cur), 0), AFDPART: 'opaque' });
rdata.set(RecordType.DS, { key_tag: 'u16', algorithm: 'u8', digest_type: 'u8', digest: 'opaque' });
rdata.set(RecordType.SSHFP, { algorithm: 'u8', fp_type: 'u8', fingerprint: 'opaque' });
rdata.set(RecordType.IPSECKEY, (d) => {
    const v = { precedence: d.next('u8').value, gateway_type: d.next('u8').value, algorithm: d.next('u8').value };
    switch (v.gateway_type) {
        case 1:
            v.gateway = IP4ADDR(d);
            break;
        case 2:
            v.gateway = IP6ADDR(d);
            break;
        case 3:
            v.gateway = d.next(DOMAINNAME).value;
            break;
    }
    v.public_key = d.next('opaque').value;
    return v;
});
rdata.set(RecordType.RRSIG, rdata.get(RecordType.SIG));
rdata.set(RecordType.NSEC, rdata.get(RecordType.NXT));
rdata.set(RecordType.DNSKEY, rdata.get(RecordType.KEY));
rdata.set(RecordType.DHCID, 'opaque');
rdata.set(RecordType.NSEC3, { hash_algorithm: 'u8', flags: 'u8', iterations: 'u16', salt: 'string', next_hashed_owner_name: 'string', type_bit_map: 'opaque' });
rdata.set(RecordType.NSEC3PARAM, { hash_algorithm: 'u8', flags: 'u8', iterations: 'u16', salt: 'string' });
rdata.set(RecordType.TLSA, { cert_usage: 'u8', selector: 'u8', matching_type: 'u8', cert_assoc_data: 'opaque' });
rdata.set(RecordType.SMIMEA, rdata.get(RecordType.TLSA));
rdata.set(RecordType.HIP, 'opaque');
rdata.set(RecordType.NINFO, 'opaque');
rdata.set(RecordType.RKEY, 'opaque');
rdata.set(RecordType.TALINK, 'opaque');
rdata.set(RecordType.CDS, rdata.get(RecordType.DS));
rdata.set(RecordType.CDNSKEY, rdata.get(RecordType.DNSKEY));
rdata.set(RecordType.OPENPGPKEY, 'opaque');
rdata.set(RecordType.CSYNC, { SOA_serial: 'u32', flags: 'u16', type_bit_map: 'opaque' });
rdata.set(RecordType.ZONEMD, 'opaque');
rdata.set(RecordType.SVCB, { priority: 'u16', domainname: DOMAINNAME, values: (d) => {
        const vals = {};
        for (let next = d.next('u16'); !next.done; next = d.next('u16')) {
            const key = next.value;
            let len = d.next('u16').value;
            const val = [];
            while (len > 0) {
                const v = d.next('string').value;
                len -= v.length + 1;
                val.push(v);
            }
            // const val = d.next(`string[${len}]`).value as string;
            switch (key) {
                case 1:
                    vals.alpn = val;
                    break;
                case 2:
                    vals.port = val;
                    break;
                case 3:
                    vals.esnikeys = val;
                    break;
                case 4:
                    vals.ipv4hint = val;
                    break;
                case 6:
                    vals.ipv6hint = val;
                    break;
                default:
                case 0:
                case 5:
                    vals[`key${key}`] = val;
                    break;
            }
        }
        return vals;
    } });
rdata.set(RecordType.HTTPSSVC, rdata.get(RecordType.SVCB));
rdata.set(RecordType.SPF, 'string[]');
rdata.set(RecordType.UINFO, 'opaque');
rdata.set(RecordType.UID, 'opaque');
rdata.set(RecordType.GID, 'opaque');
rdata.set(RecordType.UNSPEC, 'opaque');
rdata.set(RecordType.NID, 'opaque');
rdata.set(RecordType.L32, 'opaque');
rdata.set(RecordType.L64, 'opaque');
rdata.set(RecordType.LP, 'opaque');
rdata.set(RecordType.EUI48, (d) => (new Array(6)).fill(undefined).map(x => d.next('u8').value));
rdata.set(RecordType.EUI64, 'opaque');
rdata.set(RecordType.TSIG, { algorithm_name: DOMAINNAME, time_signed_upper: 'u16', time_signed: 'u32', fudge: 'u16', MAC: (d) => (new Array(d.next('u16').value)).fill(undefined).map(x => d.next('u8').value), original_id: 'u16', error: 'u16', other_len: 'u16', other_data: 'opaque' });
// Not RR types
// rdata.set(RecordType.IXFR, 'opaque');
// rdata.set(RecordType.AXFR, 'opaque');
// rdata.set(RecordType.MAILB, 'opaque');
// rdata.set(RecordType.MAILA, 'opaque');
// rdata.set(RecordType['*'], 'opaque');
rdata.set(RecordType.URI, { priority: 'u16', weight: 'u16', target: 'string[*]' });
rdata.set(RecordType.CAA, { flags: 'u8', tag: 'string', value: 'string[*]' });
rdata.set(RecordType.AVC, 'opaque');
rdata.set(RecordType.DOA, 'opaque');
rdata.set(RecordType.AMTRELAY, 'opaque');
rdata.set(RecordType.TA, 'opaque');
rdata.set(RecordType.DLV, 'opaque');
function parseToken(d, layout) {
    switch (typeof layout) {
        case "function":
            return layout(d);
        case "object":
            return Object.entries(layout).reduce((acc, [k, v]) => { acc[k] = parseToken(d, v); return acc; }, {});
        case "string":
            return d.next(layout).value;
    }
}
function parse(d, type) {
    return parseToken(d, rdata.get(type) || 'opaque');
}

const header = {
    ID: 'u16',
    // generates any kind of query.  This identifier is copied
    // the corresponding reply and can be used by the requester
    // to match up replies to outstanding queries.
    QR: 'bit',
    // query (0), or a response (1).
    Opcode: 'u4',
    // message.  This value is set by the originator of a query
    // and copied into the response.  The values are:
    // 0               a standard query (QUERY)
    // 1               an inverse query (IQUERY)
    // 2               a server status request (STATUS)
    // 3-15            reserved for future use
    AA: 'bit',
    // and specifies that the responding name server is an
    // authority for the domain name in question section.
    //
    // Note that the contents of the answer section may have
    // multiple owner names because of aliases.  The AA bit
    // corresponds to the name which matches the query name, or
    // the first owner name in the answer section.
    TC: 'bit',
    // due to length greater than that permitted on the
    // transmission channel.
    RD: 'bit',
    // is copied into the response.  If RD is set, it directs
    // the name server to pursue the query recursively.
    //     Recursive query support is optional.
    RA: 'bit',
    // response, and denotes whether recursive query support is
    // available in the name server.
    Z: 'u3',
    // and responses.
    AD: 'bit',
    CD: 'bit',
    RCODE: 'u4',
    // responses.  The values have the following
    // interpretation:
    //
    // 0               No error condition
    //
    // 1               Format error - The name server was
    //                 unable to interpret the query.
    //
    // 2               Server failure - The name server was
    //                 unable to process this query due to a
    //                 problem with the name server.
    //
    // 3               Name Error - Meaningful only for
    //                 responses from an authoritative name
    //                 server, this code signifies that the
    //                 domain name referenced in the query does
    //                 not exist.
    //
    // 4               Not Implemented - The name server does
    //                 not support the requested kind of query.
    //
    // 5               Refused - The name server refuses to
    //                 perform the specified operation for
    //                 policy reasons.  For example, a name
    //                 server may not wish to provide the
    //                 information to the particular requester,
    //                 or a name server may not wish to perform
    //                 a particular operation (e.g., zone
    // transfer) for particular data.
    //
    // 6-15            Reserved for future use.
    QDCOUNT: 'u16',
    // entries in the question section.
    ANCOUNT: 'u16',
    // resource records in the answer section.
    NSCOUNT: 'u16',
    // server resource records in the authority records
    // section.
    ARCOUNT: 'u16',
};
const HeaderLen = 12; // bytes
var CLASS;
(function (CLASS) {
    CLASS[CLASS["IN"] = 1] = "IN";
    CLASS[CLASS["CS"] = 2] = "CS";
    CLASS[CLASS["CH"] = 3] = "CH";
    CLASS[CLASS["HS"] = 4] = "HS";
})(CLASS || (CLASS = {}));
class Question {
    constructor(QNAME, QTYPE, QCLASS = CLASS.IN) {
        this.QNAME = QNAME;
        this.QTYPE = QTYPE;
        this.QCLASS = QCLASS;
    }
}
const question = {
    QNAME: 'string[]',
    // each label consists of a length octet followed by that
    // number of octets.  The domain name terminates with the
    // zero length octet for the null label of the root.  Note
    // that this field may be an odd number of octets; no
    // padding is used.
    QTYPE: 'u16',
    // The values for this field include all codes valid for a
    // TYPE field, together with some more general codes which
    // can match more than one type of RR.
    QCLASS: 'u16',
};
const record = {
    NAME: 'string[]',
    TYPE: 'u16',
    // field specifies the meaning of the data in the RDATA
    // field.
    CLASS: 'u16',
    // RDATA field.
    TTL: 'u32',
    // interval (in seconds) that the resource record may be
    // cached before it should be discarded.  Zero values are
    // interpreted to mean that the RR can only be used for the
    // transaction in progress, and should not be cached.
    RDLENGTH: 'u16',
};
/**
 * Deserialize binary RFC1035 wire format
 * Returns a Generator that accepts 's16'|'u8'|'u16'|'string'|'u32'|'string[]'|'string[*]'|'u3'|'u4'|'bit'|'opaque'|number as a parameter
 * The generator will consume bytes and yield the related native type.
 * Pass undefined to yield the current byte offset, or a number to advance the byte offset by the value number of bytes.
 * @param data buffer populated with data to deserialize
 * @param start buffer start offset
 * @param end buffer end offset
 */
function* deserialize(data, start = 0, end) {
    const view = new DataView(data, start, end && end - start);
    let ptrView;
    let len = 0;
    let val;
    let strlen;
    for (let bitOffset = 0; bitOffset < view.byteLength * 8; bitOffset += len) {
        len = 0;
        const byteOffset = Math.trunc(bitOffset / 8);
        const type = yield val;
        switch (type) {
            case 's16':
                val = view.getInt16(byteOffset);
                // Currently all s16 values are byte aligned, no shifting required
                len = 16;
                break;
            case 'u8':
                val = view.getUint8(byteOffset);
                // Currently all u8 values are byte aligned, no shifting required
                len = 8;
                break;
            case 'u16':
                val = view.getUint16(byteOffset);
                // Currently all u16 values are byte aligned, no shifting required
                len = 16;
                break;
            case 'u32':
                val = view.getUint32(byteOffset);
                // Currently all u32 values are byte aligned, no shifting required
                len = 32;
                break;
            case 'u3':
                // Only used by header Z field
                val = undefined;
                len = 3;
                break;
            case 'u4':
                val = view.getUint16(byteOffset);
                val = 0b1111 & (val >> (11 - (bitOffset % 8)));
                len = 4;
                break;
            case 'bit':
                val = view.getUint8(byteOffset);
                val = 0b1 & (val >> (7 - (bitOffset % 8)));
                len = 1;
                break;
            case 'opaque': // Consume remainder of data
                yield data.slice(byteOffset + start, end);
                return;
            case 'string[*]': // Consume remainder of data as string
                yield String.fromCodePoint(...new Uint8Array(data.slice(byteOffset + start, end)));
                return;
            case 'string': // Length prefixed string
                strlen = view.getUint8(byteOffset);
                val = String.fromCodePoint(...new Uint8Array(data.slice(byteOffset + start + 1, byteOffset + start + strlen + 1)));
                len += (strlen + 1) * 8;
                break;
            case 'string[]': // Array of length prefixed strings, zero terminated or until end of data
                val = [];
                let ptr;
                while (ptr === undefined && byteOffset + len < view.byteLength) {
                    strlen = view.getUint8(byteOffset + len);
                    if (strlen > 63) {
                        strlen = view.getUint16(byteOffset + len);
                        ptr = strlen & 0b0011111111111111;
                        len += 2;
                        break;
                    }
                    else
                        len += 1;
                    if (strlen === 0) {
                        val.push("");
                        break;
                    }
                    else {
                        val.push(String.fromCodePoint(...new Uint8Array(data.slice(byteOffset + start + len, byteOffset + start + len + strlen))));
                        len += strlen;
                    }
                }
                if (ptr !== undefined) {
                    if (!ptrView)
                        ptrView = new DataView(data);
                    // https://tools.ietf.org/html/rfc1035#section-4.1.4
                    while (true) {
                        strlen = ptrView.getUint8(ptr);
                        ++ptr;
                        if (strlen === 0) {
                            val.push("");
                            break;
                        }
                        else if (strlen > 63) {
                            strlen = view.getUint16(ptr);
                            ptr = strlen & 0b0011111111111111;
                        }
                        else {
                            val.push(String.fromCodePoint(...new Uint8Array(data.slice(ptr, ptr + strlen))));
                            ptr += strlen;
                        }
                    }
                }
                len *= 8;
                break;
            case undefined: // Return current byteOffset if no type provided
                val = byteOffset;
                break;
            default:
                if (typeof type === 'number') {
                    len = type * 8;
                }
                else if (typeof type === 'string' && type.startsWith('string[')) {
                    len = parseInt(type.substring(7, type.length - 1), 10);
                    val = String.fromCodePoint(...new Uint8Array(data.slice(byteOffset + start, byteOffset + start + len)));
                    len *= 8;
                }
                else
                    throw Error('Unknown token type');
        }
    }
    yield val;
    return;
}
// TODO implement https://tools.ietf.org/html/rfc1035#section-2.3.4
// TODO support truncated responses
function setString(view, val) {
    let len = 0;
    view.setUint8(0, val.length);
    for (; len < val.length; ++len) {
        view.setUint8(1 + len, val.charCodeAt(len));
    }
}
/**
 * Serialize binary RFC1035 wire format
 * Returns a Generator that accepts tuples of ('s16'|'u8'|'u16'|'string'|'u32'|'string[]'|'string[*]'|'u3'|'u4'|'bit'|'opaque', number|string|string[]|ArrayBuffer) as a parameter
 * The generator will convert the second tuple value to the binary representation specified in the first tuple value
 * @param data buffer to populate
 */
function* serialize(data) {
    const view = new DataView(data);
    let len = 0;
    for (let bitOffset = 0; bitOffset < view.byteLength * 8; bitOffset += len) {
        len = 0;
        let byteOffset = Math.trunc(bitOffset / 8);
        const [type, val] = yield byteOffset;
        switch (type) {
            case 's16':
                if (typeof val !== 'number')
                    throw Error(`Token value mismatch ${type} vs ${typeof val}`);
                view.setInt16(byteOffset, val);
                // Currently all s16 values are byte aligned, no shifting required
                len = 16;
                break;
            case 'u8':
                if (typeof val !== 'number')
                    throw Error(`Token value mismatch ${type} vs ${typeof val}`);
                view.setUint8(byteOffset, val);
                // Currently all u8 values are byte aligned, no shifting required
                len = 8;
                break;
            case 'u16':
                if (typeof val !== 'number')
                    throw Error(`Token value mismatch ${type} vs ${typeof val}`);
                view.setUint16(byteOffset, val);
                // Currently all u16 values are byte aligned, no shifting required
                len = 16;
                break;
            case 'u32':
                if (typeof val !== 'number')
                    throw Error(`Token value mismatch ${type} vs ${typeof val}`);
                view.setUint32(byteOffset, val);
                // Currently all u32 values are byte aligned, no shifting required
                len = 32;
                break;
            case 'u3':
                // Only used by header Z field, no-op
                len = 3;
                break;
            case 'u4':
                if (typeof val !== 'number')
                    throw Error(`Token value mismatch ${type} vs ${typeof val}`);
                let bigval = view.getUint16(byteOffset);
                bigval |= val << (11 - (bitOffset % 8));
                view.setUint16(byteOffset, bigval);
                len = 4;
                break;
            case 'bit':
                if (typeof val !== 'number')
                    throw Error(`Token value mismatch ${type} vs ${typeof val}`);
                let byte = view.getUint8(byteOffset);
                byte |= val << (7 - (bitOffset % 8));
                view.setUint8(byteOffset, byte);
                len = 1;
                break;
            case 'string[*]': // Write remainder of data as string
                if (typeof val !== 'string')
                    throw Error(`Token value mismatch ${type} vs ${typeof val}`);
                if (val.length < view.byteLength - byteOffset) {
                    for (; len < val.length; ++len) {
                        view.setUint8(byteOffset + len, val.charCodeAt(len));
                    }
                }
                return;
            case 'string': // Length prefixed string
                if (typeof val !== 'string')
                    throw Error(`Token value mismatch ${type} vs ${typeof val}`);
                setString(new DataView(data, byteOffset, val.length + 1), val);
                len = (val.length + 1) * 8;
                break;
            case 'string[]': // Array of length prefixed strings, zero terminated or until end of data
                if (!Array.isArray(val))
                    throw Error(`Token value mismatch ${type} vs ${typeof val}`);
                for (const str of val) {
                    if (typeof str !== 'string')
                        throw Error(`Token value mismatch 'string' vs ${typeof str}`);
                    setString(new DataView(data, byteOffset, str.length + 1), str);
                    byteOffset += str.length + 1;
                    len += (str.length + 1) * 8;
                }
                if (val[val.length - 1].length !== 0) { // Zero terminate if last element of val not empty
                    view.setUint8(byteOffset, 0);
                    len += 8;
                }
                break;
            case 'opaque':
                if (val instanceof Uint8Array) {
                    val.forEach((v, i) => view.setUint8(byteOffset + i, v));
                    len += val.length * 8;
                }
                break;
            default:
                throw Error(`Unknown token type: ${type}`);
        }
    }
    return;
}
function buildRequest(questions, recursive = true) {
    const totalLen = HeaderLen
        + (questions.length * 4) // Bytes for QTYPE+QCLASS
        + questions.reduce((acc, q) => acc + q.QNAME.length + q.QNAME.reduce((a, c) => a + c.length, 0) + (q.QNAME[q.QNAME.length - 1].length === 0 ? 0 : 1), 0); // Bytes required for QNAMEs
    const buf = new ArrayBuffer(totalLen);
    const encoder = serialize(buf);
    encoder.next();
    const head = { ID: 0, QR: 0, Opcode: 0, AA: 0, TC: 0, RD: recursive ? 1 : 0, QDCOUNT: questions.length };
    for (const [token, type] of Object.entries(header))
        encoder.next([type, head[token] || 0]);
    for (const q of questions) {
        for (const [token, type] of Object.entries(question))
            encoder.next([type, q[token]]);
    }
    return buf;
}
function parseResponse(data) {
    const decoder = deserialize(data);
    decoder.next();
    const response = { header: {}, question: [], answer: [], authority: [], additional: [] };
    // Header
    for (const [token, type] of Object.entries(header))
        response.header[token] = decoder.next(type).value;
    // Question[]
    for (let i = 0; i < response.header.QDCOUNT; ++i) {
        const q = {};
        for (const [token, type] of Object.entries(question))
            q[token] = decoder.next(type).value;
        response.question.push(q);
    }
    // answer, authority, additional
    for (const [count, category] of [[response.header.ANCOUNT, response.answer], [response.header.NSCOUNT, response.authority], [response.header.ARCOUNT, response.additional]]) {
        for (let i = 0; i < count; ++i) {
            const r = {};
            for (const [token, type] of Object.entries(record))
                r[token] = decoder.next(type).value;
            const byteOffset = decoder.next().value;
            const end = byteOffset + r.RDLENGTH;
            if (end > data.byteLength)
                throw Error(`RDLENGTH extends past end of received data`);
            decoder.next(r.RDLENGTH); // Advance by RDLENGTH
            const rdataDecoder = deserialize(data, byteOffset, end);
            rdataDecoder.next();
            r.RDATA = parse(rdataDecoder, r.TYPE);
            category.push(r);
        }
    }
    return response;
}

/**
 * RFS8484 DoH Resolver
 * https://tools.ietf.org/html/rfc8484
 */
function base64url_encode(buffer) {
    return btoa(Array.from(new Uint8Array(buffer), b => String.fromCharCode(b)).join(''))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
}
function ipString(type, ip) {
    if (type === RecordType.A)
        return ip.map(n => n.toString(10)).join('.');
    else if (type === RecordType.AAAA) {
        // IP6 shortening
        let start = 0;
        let len = 0;
        let longestLen = 0;
        let longestStart = 0;
        for (let i = 0; i < ip.length; ++i) {
            if (ip[i] === 0 && len === 0) {
                start = i;
                ++len;
            }
            else if (ip[i] !== 0 && len !== 0) {
                if (len > longestLen) {
                    longestLen = len;
                    longestStart = start;
                }
                len = 0;
            }
            else if (len !== 0)
                ++len;
        }
        if (longestLen === ip.length || len === ip.length)
            return '::';
        if (longestLen !== 0 || len !== 0) {
            const ipStr = ip.map(n => n.toString(16));
            return [...ipStr.slice(0, longestStart), '', ...ipStr.slice(longestStart + (longestLen || len))].join(':');
        }
        return ip.map(n => n.toString(16)).join(':');
    }
}
class Resolver extends BaseResolver {
    constructor() {
        super(...arguments);
        this.servers = ['cloudflare-dns.com'];
    }
    resolve(hostname, rrtype, options) {
        if (rrtype === "ANY")
            rrtype = "*";
        else if (rrtype === undefined)
            rrtype = 'A';
        const payload = base64url_encode(buildRequest([new Question(hostname.split('.'), RecordType[rrtype])]));
        return this._fetch(`https://${this.getServers()[0]}/dns-query?dns=${payload}`, { headers: new Headers({ 'accept': 'application/dns-message' }) })
            .then(response => response.arrayBuffer())
            .then(parseResponse)
            .then(response => {
            if (!response.answer)
                throw DNSError.NODATA;
            if (options && options.raw)
                return response;
            switch (rrtype) {
                case 'A':
                case 'AAAA':
                    if (options && options.ttl)
                        return response.answer.map(item => ({
                            type: rrtype,
                            address: ipString(item.TYPE, item.RDATA),
                            ttl: item.TTL
                        }));
                    return response.answer.map(item => ipString(item.TYPE, item.RDATA));
                default:
                case 'CNAME':
                case 'NS':
                case 'PTR':
                    return response.answer.map(item => item.RDATA.join ? item.RDATA.filter((i) => !!i).join('.') : item.RDATA);
                case 'ANY':
                    return response.answer.map(item => {
                        switch (item.TYPE) {
                            case RecordType.A:
                                return {
                                    type: 'A',
                                    address: ipString(item.TYPE, item.RDATA),
                                    ttl: item.TTL
                                };
                            case RecordType.AAAA:
                                return {
                                    type: 'AAAA',
                                    address: ipString(item.TYPE, item.RDATA),
                                    ttl: item.TTL
                                };
                            case RecordType.CNAME:
                                return { type: 'CNAME', value: item.RDATA };
                            case RecordType.NS:
                                return { type: 'NS', value: item.RDATA };
                            case RecordType.PTR:
                                return { type: 'PTR', value: item.RDATA };
                            case RecordType.NAPTR:
                                return {
                                    type: 'NAPTR',
                                    flags: item.RDATA.FLAGS,
                                    order: item.RDATA.ORDER,
                                    preference: item.RDATA.PREFERENCE,
                                    regexp: item.RDATA.REGEXP,
                                    replacement: item.RDATA.REPLACEMENT.filter((x) => !!x).join('.'),
                                    service: item.RDATA.SERVICES
                                };
                            case RecordType.SOA:
                                return {
                                    type: 'SOA',
                                    minttl: item.RDATA.MINIMUM,
                                    expire: item.RDATA.EXPIRE,
                                    retry: item.RDATA.RETRY,
                                    refresh: item.RDATA.REFRESH,
                                    serial: item.RDATA.SERIAL,
                                    hostmaster: item.RDATA.RNAME.filter((x) => !!x).join('.'),
                                    nsname: item.RDATA.MNAME.filter((x) => !!x).join('.')
                                };
                            case RecordType.MX:
                                return {
                                    type: 'MX',
                                    exchange: item.RDATA.EXCHANGE.filter((x) => !!x).join('.'),
                                    priority: item.RDATA.PREFERENCE
                                };
                            case RecordType.TXT:
                                return { type: 'TXT', entries: item.RDATA };
                            case RecordType.CAA:
                                return {
                                    type: 'CAA',
                                    critical: item.RDATA.flags,
                                    [item.RDATA.tag]: item.RDATA.value
                                };
                            case RecordType.SRV:
                                return {
                                    type: "SRV",
                                    weight: item.RDATA.weight,
                                    priority: item.RDATA.priority,
                                    name: item.RDATA.target.filter((x) => !!x).join('.'),
                                    port: item.RDATA.port
                                };
                        }
                    });
                case 'MX':
                    return response.answer.map(item => ({
                        exchange: item.RDATA.EXCHANGE.filter((x) => !!x).join('.'),
                        priority: item.RDATA.PREFERENCE
                    }));
                case 'NAPTR':
                    return response.answer.map(item => ({
                        flags: item.RDATA.FLAGS,
                        order: item.RDATA.ORDER,
                        preference: item.RDATA.PREFERENCE,
                        regexp: item.RDATA.REGEXP,
                        replacement: item.RDATA.REPLACEMENT.filter((x) => !!x).join('.'),
                        service: item.RDATA.SERVICES
                    }));
                case 'SOA':
                    return response.answer.map(item => ({
                        minttl: item.RDATA.MINIMUM,
                        expire: item.RDATA.EXPIRE,
                        retry: item.RDATA.RETRY,
                        refresh: item.RDATA.REFRESH,
                        serial: item.RDATA.SERIAL,
                        hostmaster: item.RDATA.RNAME.filter((x) => !!x).join('.'),
                        nsname: item.RDATA.MNAME.filter((x) => !!x).join('.')
                    }))[0];
                case 'SRV':
                    return response.answer.map(item => ({
                        weight: item.RDATA.weight,
                        priority: item.RDATA.priority,
                        name: item.RDATA.target.filter((x) => !!x).join('.'),
                        port: item.RDATA.port
                    }));
                case 'TXT':
                    return response.answer.map(item => item.RDATA);
                case 'CAA':
                    return response.answer.filter(item => item.TYPE === RecordType.CAA).map(item => ({
                        critical: item.RDATA.flags,
                        [item.RDATA.tag]: item.RDATA.value
                    }));
            }
        });
    }
}

/**
 * Wrapper around Promise based Resolver implementations to support callback interface.
 * Pass an instantiated PromiseResolver to constructor to wrap the resolver.
 * Defaults to CloudFlare resolver.
 */
class CallbackResolver {
    constructor(options) {
        if (options === undefined) {
            this._resolver = new Resolver();
        }
        else if ('timeout' in options) {
            this._resolver = new Resolver(options);
        }
        else {
            this._resolver = options;
        }
    }
    cancel() {
        this._resolver.cancel();
    }
    getServers() {
        return this._resolver.getServers();
    }
    resolve(hostname, ...args) {
        const callback = args.pop();
        this._resolver.resolve(hostname, args[0]).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolve4(hostname, ...args) {
        const callback = args.pop();
        this._resolver.resolve4(hostname, args[0]).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolve6(hostname, ...args) {
        const callback = args.pop();
        this._resolver.resolve6(hostname, args[0]).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolveAny(hostname, callback) {
        this._resolver.resolveAny(hostname).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolveCaa(hostname, callback) {
        this._resolver.resolveCaa(hostname).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolveCname(hostname, callback) {
        this._resolver.resolveCname(hostname).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolveMx(hostname, callback) {
        this._resolver.resolveMx(hostname).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolveNaptr(hostname, callback) {
        this._resolver.resolveNaptr(hostname).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolveNs(hostname, callback) {
        this._resolver.resolveNs(hostname).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolvePtr(hostname, callback) {
        this._resolver.resolvePtr(hostname).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolveSoa(hostname, callback) {
        this._resolver.resolveSoa(hostname).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolveSrv(hostname, callback) {
        this._resolver.resolveSrv(hostname).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    resolveTxt(hostname, callback) {
        this._resolver.resolveTxt(hostname).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    reverse(hostname, callback) {
        this._resolver.reverse(hostname).then(v => callback(undefined, v)).catch(e => callback(e, undefined));
    }
    setLocalAddress(ipv4, ipv6) {
        this._resolver.setLocalAddress(ipv4, ipv6);
    }
    setServers(servers) {
        this._resolver.setServers(servers);
    }
}
const defaultResolver = new CallbackResolver();
const defaultPromiseResolver = new Resolver();
function lookupPromise(hostname, ...args) {
    const options = args[0];
    let family = options || 4;
    let hints = 0; // Ignored, not supported
    let all = false;
    let verbatim = false; // Ignored, always false
    if (typeof options === 'object') {
        family = options.family || family;
        hints = options.hints || hints;
        all = options.all || all;
        verbatim = options.verbatim || verbatim;
    }
    let promise = Promise.resolve([]);
    if (family === 6 || family === 0) {
        promise = defaultPromiseResolver.resolve(hostname, 'AAAA').then(r => r.map((v) => ({ address: v, family: 6 })));
    }
    if (family === 4 || family === 0) {
        promise = Promise.all([promise, defaultPromiseResolver.resolve(hostname, 'A').then(r => r.map((v) => ({ address: v, family: 4 })))]).then(r => r[0].concat(r[1]));
    }
    return promise.then(result => {
        if (result.length === 0)
            throw DNSError.NODATA;
        return all ? result : result[0];
    });
}
function lookupServicePromise(address, port) {
    throw DNSError.NOTIMP;
}
function lookup(hostname, ...args) {
    const callback = args.pop();
    lookupPromise(hostname, args[0]).then(result => Array.isArray(result) ? callback(undefined, result) : callback(undefined, result.address, result.family)).catch(err => callback(err));
}
function lookupService(address, port, callback) {
    lookupServicePromise().then(v => callback(undefined, v.hostname, v.service)).catch(e => callback(e));
}
var index = Object.assign(Object.assign({}, constants), { Resolver: CallbackResolver, promises: {
        Resolver: Resolver,
        lookup: lookupPromise,
        lookupService: lookupServicePromise,
        getServers: defaultPromiseResolver.getServers.bind(defaultPromiseResolver),
        resolve: defaultPromiseResolver.resolve.bind(defaultPromiseResolver),
        resolve4: defaultPromiseResolver.resolve4.bind(defaultPromiseResolver),
        resolve6: defaultPromiseResolver.resolve6.bind(defaultPromiseResolver),
        resolveAny: defaultPromiseResolver.resolveAny.bind(defaultPromiseResolver),
        resolveCname: defaultPromiseResolver.resolveCname.bind(defaultPromiseResolver),
        resolveCaa: defaultPromiseResolver.resolveCaa.bind(defaultPromiseResolver),
        resolveMx: defaultPromiseResolver.resolveMx.bind(defaultPromiseResolver),
        resolveNaptr: defaultPromiseResolver.resolveNaptr.bind(defaultPromiseResolver),
        resolveNs: defaultPromiseResolver.resolveNs.bind(defaultPromiseResolver),
        resolvePtr: defaultPromiseResolver.resolvePtr.bind(defaultPromiseResolver),
        resolveSoa: defaultPromiseResolver.resolveSoa.bind(defaultPromiseResolver),
        resolveSrv: defaultPromiseResolver.resolveSrv.bind(defaultPromiseResolver),
        resolveTxt: defaultPromiseResolver.resolveTxt.bind(defaultPromiseResolver),
        reverse: defaultPromiseResolver.reverse.bind(defaultPromiseResolver),
        setServers: defaultPromiseResolver.setServers.bind(defaultPromiseResolver),
    }, lookup,
    lookupService, getServers: defaultResolver.getServers.bind(defaultResolver), resolve: defaultResolver.resolve.bind(defaultResolver), resolve4: defaultResolver.resolve4.bind(defaultResolver), resolve6: defaultResolver.resolve6.bind(defaultResolver), resolveAny: defaultResolver.resolveAny.bind(defaultResolver), resolveCname: defaultResolver.resolveCname.bind(defaultResolver), resolveCaa: defaultResolver.resolveCaa.bind(defaultResolver), resolveMx: defaultResolver.resolveMx.bind(defaultResolver), resolveNaptr: defaultResolver.resolveNaptr.bind(defaultResolver), resolveNs: defaultResolver.resolveNs.bind(defaultResolver), resolvePtr: defaultResolver.resolvePtr.bind(defaultResolver), resolveSoa: defaultResolver.resolveSoa.bind(defaultResolver), resolveSrv: defaultResolver.resolveSrv.bind(defaultResolver), resolveTxt: defaultResolver.resolveTxt.bind(defaultResolver), reverse: defaultResolver.reverse.bind(defaultResolver), setServers: defaultResolver.setServers.bind(defaultResolver) });

export default index;
//# sourceMappingURL=index.esm.js.map
